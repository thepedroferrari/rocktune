name: CI/CD

on:
  push:
    branches: [master, main]
  pull_request:
    branches: [master, main]
  workflow_dispatch:

jobs:
  validate-web:
    name: Validate Web Application
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup Deno
        uses: denoland/setup-deno@v2
        with:
          deno-version: v2.x

      - name: Cache Deno dependencies
        uses: actions/cache@v4
        with:
          path: |
            ~/.cache/deno
            web/node_modules
          key: deno-${{ hashFiles('web/deno.lock') }}
          restore-keys: deno-

      - name: Validate catalog.json
        run: |
          echo "Validating catalog.json..."
          cat web/catalog.json | jq empty
          # Check for duplicate winget IDs
          duplicates=$(jq -r 'to_entries | .[].value.id' web/catalog.json | sort | uniq -d)
          if [ -n "$duplicates" ]; then
            echo "❌ Duplicate package IDs: $duplicates"
            exit 1
          fi
          echo "✓ catalog.json is valid"

      - name: Validate web app (lint, typecheck, build)
        working-directory: web
        run: deno task validate

      - name: Audit catalogs
        working-directory: web
        run: |
          deno task catalog:audit
          deno task share:audit

  validate-powershell:
    name: Validate PowerShell Modules
    runs-on: windows-latest
    steps:
      - uses: actions/checkout@v4

      - name: Check PowerShell syntax
        shell: pwsh
        run: |
          $errors = @()
          Get-ChildItem -Path . -Filter *.ps1 -Recurse |
            Where-Object { $_.FullName -notlike '*_external*' -and $_.FullName -notlike '*node_modules*' } |
            ForEach-Object {
              $tokens = $null
              $parseErrors = $null
              [System.Management.Automation.Language.Parser]::ParseFile($_.FullName, [ref]$tokens, [ref]$parseErrors)
              if ($parseErrors) {
                $errors += "$($_.Name): $($parseErrors | ForEach-Object { $_.Message })"
              }
            }
          Get-ChildItem -Path . -Filter *.psm1 -Recurse |
            Where-Object { $_.FullName -notlike '*_external*' -and $_.FullName -notlike '*node_modules*' } |
            ForEach-Object {
              $tokens = $null
              $parseErrors = $null
              [System.Management.Automation.Language.Parser]::ParseFile($_.FullName, [ref]$tokens, [ref]$parseErrors)
              if ($parseErrors) {
                $errors += "$($_.Name): $($parseErrors | ForEach-Object { $_.Message })"
              }
            }
          if ($errors.Count -gt 0) {
            Write-Host "❌ PowerShell syntax errors found:" -ForegroundColor Red
            $errors | ForEach-Object { Write-Host "  $_" }
            exit 1
          }
          Write-Host "✓ All PowerShell files have valid syntax" -ForegroundColor Green

      - name: Test module imports
        shell: pwsh
        run: |
          $modules = Get-ChildItem -Path modules -Filter *.psm1 -Recurse
          foreach ($mod in $modules) {
            try {
              Import-Module $mod.FullName -Force -ErrorAction Stop
              Write-Host "✓ $($mod.Name)" -ForegroundColor Green
            } catch {
              Write-Host "❌ $($mod.Name): $_" -ForegroundColor Red
              exit 1
            }
          }
